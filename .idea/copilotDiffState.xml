<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/plugins/maib/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/plugins/maib/__init__.py" />
              <option name="originalContent" value="from nonebot import on_regex&#10;from nonebot.plugin import PluginMetadata&#10;&#10;from .adx_download import handle_download&#10;&#10;# from .config import Config&#10;&#10;__plugin_meta__ = PluginMetadata(&#10;    name=&quot;lyra-maib&quot;,&#10;    description=&quot;一个QQ群的 舞萌DX 功能机器人。&quot;,&#10;    usage=&quot;使用 help 查询使用方法&quot;,&#10;    # config=Config,&#10;)&#10;&#10;# config = get_plugin_config(Config)&#10;&#10;&#10;adx_download = on_regex(r&quot;下载谱面\s*([0-9]+)&quot;, priority=5)&#10;&#10;@adx_download.handle()&#10;async def _(bot, event):&#10;    await handle_download(bot, event)&#10;" />
              <option name="updatedContent" value="from nonebot import on_regex&#10;from nonebot.plugin import PluginMetadata&#10;&#10;from .adx_download import handle_download&#10;&#10;# from .config import Config&#10;&#10;__plugin_meta__ = PluginMetadata(&#10;    name=&quot;lyra-maib&quot;,&#10;    description=&quot;一个QQ群的 舞萌DX 功能机器人。&quot;,&#10;    usage=&quot;使用 help 查询使用方法&quot;,&#10;    # config=Config,&#10;)&#10;&#10;# config = get_plugin_config(Config)&#10;&#10;&#10;adx_download = on_regex(r&quot;下载谱面\s*([0-9]+)&quot;, priority=5)&#10;&#10;@adx_download.handle()&#10;async def _(bot, event, matcher):&#10;    await handle_download(bot, event, matcher)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/plugins/maib/adx_download.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/plugins/maib/adx_download.py" />
              <option name="originalContent" value="import tempfile&#10;import httpx&#10;import os&#10;import re&#10;import zipfile&#10;&#10;from nonebot import logger&#10;from nonebot.adapters.onebot.v11 import Event, Bot&#10;from nonebot.params import CommandArg&#10;from nonebot.exception import FinishedException&#10;&#10;from . import adx_download&#10;&#10;&#10;async def handle_download(bot: Bot, event: Event, matcher):&#10;    msg = str(event.get_message())&#10;    logger.info(f&quot;收到消息: {msg}&quot;)&#10;    # 提取数字&#10;    match = re.search(r&quot;下载谱面\s*([0-9]+)&quot;, msg)&#10;    if match:&#10;        song_id = match.group(1)&#10;        logger.info(f&quot;提取到song_id: {song_id}&quot;)&#10;        url = f&quot;https://api.milkbot.cn/server/api/nobga_download?id={song_id}&quot;&#10;        logger.info(f&quot;下载链接: {url}&quot;)&#10;        await matcher.send(f&quot;正在下载曲目[{song_id}]，请稍候……&quot;)&#10;        tmp_dir = tempfile.gettempdir()&#10;        tmp_path = os.path.join(tmp_dir, f&quot;{song_id}.zip&quot;)&#10;        logger.info(f&quot;临时文件路径: {tmp_path}&quot;)&#10;        try:&#10;            async with httpx.AsyncClient(follow_redirects=True) as client:&#10;                logger.info(&quot;开始请求下载文件&quot;)&#10;                resp = await client.get(url)&#10;                logger.info(f&quot;HTTP状态码: {resp.status_code}&quot;)&#10;                resp.raise_for_status()&#10;                with open(tmp_path, &quot;wb&quot;) as f:&#10;                    f.write(resp.content)&#10;                logger.info(f&quot;文件已写��: {tmp_path}, 大小: {os.path.getsize(tmp_path)} bytes&quot;)&#10;            # 解压并读取maidata.txt第一行&#10;            maidata_title = None&#10;            logger.info(&quot;开始解压zip文件&quot;)&#10;            with zipfile.ZipFile(tmp_path, &quot;r&quot;) as zip_ref:&#10;                logger.info(f&quot;zip内容: {zip_ref.namelist()}&quot;)&#10;                for name in zip_ref.namelist():&#10;                    if name.lower() == &quot;maidata.txt&quot;:&#10;                        logger.info(f&quot;找到maidata.txt: {name}&quot;)&#10;                        with zip_ref.open(name) as maidata_file:&#10;                            first_line = maidata_file.readline().decode(&quot;utf-8&quot;, errors=&quot;ignore&quot;).strip()&#10;                            logger.info(f&quot;maidata.txt第一行: {first_line}&quot;)&#10;                            title_match = re.search(r&quot;&amp;title=(.*)&quot;, first_line)&#10;                            if title_match:&#10;                                maidata_title = title_match.group(1)&#10;                                logger.info(f&quot;提取到title: {maidata_title}&quot;)&#10;                        break&#10;            # 上传到QQ群文件&#10;            group_id = event.group_id if hasattr(event, &quot;group_id&quot;) else None&#10;            logger.info(f&quot;group_id: {group_id}&quot;)&#10;            if not group_id:&#10;                logger.info(&quot;未检测到group_id，非群聊环境&quot;)&#10;                await matcher.finish(&quot;只能在群聊中使用该命令。&quot;)&#10;            logger.info(&quot;开始上传群文件&quot;)&#10;            await bot.call_api(&#10;                &quot;upload_group_file&quot;,&#10;                group_id=group_id,&#10;                file=tmp_path,&#10;                name=f&quot;{song_id}.zip&quot;&#10;            )&#10;            logger.info(&quot;上传群文件成功&quot;)&#10;            if maidata_title:&#10;                await matcher.finish(f&quot;曲目[{song_id}]({maidata_title}) 已上传到群文件：{song_id}.zip&quot;)&#10;            else:&#10;                await matcher.finish(f&quot;曲目[{song_id}]已上传到群文件：{song_id}.zip&quot;)&#10;        except Exception as e:&#10;            if isinstance(e, FinishedException):&#10;                raise&#10;            logger.info(f&quot;发生异常: {e}&quot;)&#10;            await matcher.finish(f&quot;下载或上传失败：{e}&quot;)&#10;        finally:&#10;            if os.path.exists(tmp_path):&#10;                try:&#10;                    os.remove(tmp_path)&#10;                    logger.info(f&quot;已删除临时文件: {tmp_path}&quot;)&#10;                except Exception as e:&#10;                    logger.info(f&quot;删除临时文件失败: {e}&quot;)&#10;    else:&#10;        logger.info(&quot;未识别到谱面ID&quot;)&#10;        await matcher.finish(&quot;未识别到谱面ID，请检查格式。&quot;)&#10;" />
              <option name="updatedContent" value="import tempfile&#10;import httpx&#10;import os&#10;import re&#10;import zipfile&#10;&#10;from nonebot import logger&#10;from nonebot.adapters.onebot.v11 import Event, Bot&#10;from nonebot.params import CommandArg&#10;from nonebot.exception import FinishedException&#10;&#10;from . import adx_download&#10;&#10;&#10;async def handle_download(bot: Bot, event: Event, matcher):&#10;    msg = str(event.get_message())&#10;    logger.info(f&quot;收到消息: {msg}&quot;)&#10;    # 提取数字&#10;    match = re.search(r&quot;下载谱面\s*([0-9]+)&quot;, msg)&#10;    if match:&#10;        song_id = match.group(1)&#10;        logger.info(f&quot;提取到song_id: {song_id}&quot;)&#10;        url = f&quot;https://api.milkbot.cn/server/api/nobga_download?id={song_id}&quot;&#10;        logger.info(f&quot;下载链接: {url}&quot;)&#10;        await matcher.send(f&quot;正在下载曲目[{song_id}]，请稍候……&quot;)&#10;        tmp_dir = tempfile.gettempdir()&#10;        tmp_path = os.path.join(tmp_dir, f&quot;{song_id}.zip&quot;)&#10;        logger.info(f&quot;临时文件路径: {tmp_path}&quot;)&#10;        try:&#10;            async with httpx.AsyncClient(follow_redirects=True) as client:&#10;                logger.info(&quot;开始请求下载文件&quot;)&#10;                resp = await client.get(url)&#10;                logger.info(f&quot;HTTP状态码: {resp.status_code}&quot;)&#10;                resp.raise_for_status()&#10;                with open(tmp_path, &quot;wb&quot;) as f:&#10;                    f.write(resp.content)&#10;                logger.info(f&quot;文件已写��: {tmp_path}, 大小: {os.path.getsize(tmp_path)} bytes&quot;)&#10;            # 解压并读取maidata.txt第一行&#10;            maidata_title = None&#10;            logger.info(&quot;开始解压zip文件&quot;)&#10;            with zipfile.ZipFile(tmp_path, &quot;r&quot;) as zip_ref:&#10;                logger.info(f&quot;zip内容: {zip_ref.namelist()}&quot;)&#10;                for name in zip_ref.namelist():&#10;                    if name.lower() == &quot;maidata.txt&quot;:&#10;                        logger.info(f&quot;找到maidata.txt: {name}&quot;)&#10;                        with zip_ref.open(name) as maidata_file:&#10;                            first_line = maidata_file.readline().decode(&quot;utf-8&quot;, errors=&quot;ignore&quot;).strip()&#10;                            logger.info(f&quot;maidata.txt第一行: {first_line}&quot;)&#10;                            title_match = re.search(r&quot;&amp;title=(.*)&quot;, first_line)&#10;                            if title_match:&#10;                                maidata_title = title_match.group(1)&#10;                                logger.info(f&quot;提取到title: {maidata_title}&quot;)&#10;                        break&#10;            # 上传到QQ群文件&#10;            group_id = event.group_id if hasattr(event, &quot;group_id&quot;) else None&#10;            logger.debug(f&quot;group_id: {group_id}&quot;)&#10;            if not group_id:&#10;                logger.debug(&quot;未检测到group_id，非群聊环境&quot;)&#10;                await matcher.finish(&quot;只能在群聊中使用该命令。&quot;)&#10;            logger.debug(&quot;开始上传群文件&quot;)&#10;            await bot.call_api(&#10;                &quot;upload_group_file&quot;,&#10;                group_id=group_id,&#10;                file=tmp_path,&#10;                name=f&quot;{song_id}.zip&quot;&#10;            )&#10;            logger.debug(&quot;上传群文件成功&quot;)&#10;            if maidata_title:&#10;                await matcher.finish(f&quot;曲目[{song_id}]({maidata_title}) 已上传到群文件：{song_id}.zip&quot;)&#10;            else:&#10;                await matcher.finish(f&quot;曲目[{song_id}]已上传到群文件：{song_id}.zip&quot;)&#10;        except Exception as e:&#10;            if isinstance(e, FinishedException):&#10;                raise&#10;            logger.info(f&quot;发生异常: {e}&quot;)&#10;            await matcher.finish(f&quot;下载或上传失败：{e}&quot;)&#10;        finally:&#10;            if os.path.exists(tmp_path):&#10;                try:&#10;                    os.remove(tmp_path)&#10;                    logger.debug(f&quot;已删除临时文件: {tmp_path}&quot;)&#10;                except Exception as e:&#10;                    logger.info(f&quot;删除临时文件失败: {e}&quot;)&#10;    else:&#10;        logger.debug(&quot;未识别到谱面ID&quot;)&#10;        await matcher.finish(&quot;未识别到谱面ID，请检查格式。&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>